#include <bits/stdc++.h>
#include <cmath>

using namespace std;

// ST表，稀疏表，主要用来解决RMQ（区间最大/最小值查询）的问题，主要应用倍增思想
// 注意是查询，如果是修改就只能用线段树了

// 预处理ST表
// 倍增法递推，用两个等长小区间拼凑一个大区间
// f[i][j]表示以第i个数为起点，长度为2^j的区间中的最大值
// f[i][j] = max(f[i][j-1], f[i + 2^j-1][j-1])

// 处理询问
// 对查询区间[l,r]分割，拼凑，区间长度的指数k = log2(r - l + 1)
// 区间[l, r]可以用两个长度为2^k的区间重叠拼成，因为各种情况，会在中间有重叠，不影响
// max(f[l][k], f[r - (1<<k) + 1][k])

int f[100005][22], n, m;

int main() {
    cin >> n >> m;

    // 长度为1的区间最大最小值就是他自己
    for (int i = 1; i <= n; i++) scanf("%d", &f[i][0]);

    // 预处理
    // 先枚举区间长度，保证后边的状态空间可以用前面递推
    for (int j = 1; j <= 20; j++) {   // 枚举区间长度
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {  //枚举起点
            f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
        }
    }

    for (int i = 1, l, r; i <= m; i++) {
        cin >> l >> r;
        int k = log2(r - l + 1); //区间长度的指数
        printf("%d\n", max(f[l][k], f[r - (1 << k) + 1][k]));
    }

    return 0;
}
